

/* damagetype
#define DMG_GENERIC								0					// generic damage was done
#define DMG_CRUSH									(1 << 0)	// crushed by falling or moving object. 													// NOTE: It's assumed crush damage is occurring as a result of physics collision, so no extra physics force is generated by crush damage.													// DON'T use DMG_CRUSH when damaging entities unless it's the result of a physics collision. You probably want DMG_CLUB instead.
#define DMG_BULLET								(1 << 1)	// shot
#define DMG_SLASH									(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN									(1 << 3)	// heat burned
#define DMG_VEHICLE								(1 << 4)	// hit by a vehicle
#define DMG_FALL									(1 << 5)	// fell too far
#define DMG_BLAST									(1 << 6)	// explosive blast damage
#define DMG_CLUB									(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK									(1 << 8)	// electric shock
#define DMG_SONIC									(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM						(1 << 10)	// laser or other high energy beam 
#define DMG_PREVENT_PHYSICS_FORCE	(1 << 11)	// Prevent a physics force 
#define DMG_NEVERGIB							(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB							(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.
#define DMG_DROWN									(1 << 14)	// Drowning
#define DMG_PARALYZE							(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS							(1 << 16)	// nerve toxins, very bad
#define DMG_POISON								(1 << 17)	// blood poisoning - heals over time like drowning damage
#define DMG_RADIATION							(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER					(1 << 19)	// drowning recovery
#define DMG_ACID									(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN							(1 << 21)	// in an oven
#define DMG_REMOVENORAGDOLL				(1 << 22)	// with this bit OR'd in, no ragdoll will be created, and the target will be quietly removed.
												// use this to kill an entity that you've already got a server-side ragdoll for
#define DMG_PHYSGUN								(1 << 23)	// Hit by manipulator. Usually doesn't do any damage.
#define DMG_PLASMA								(1 << 24)	// Shot by Cremator
#define DMG_AIRBOAT								(1 << 25)	// Hit by the airboat's gun
#define DMG_DISSOLVE							(1 << 26)	// Dissolving!
#define DMG_BLAST_SURFACE					(1 << 27)	// A blast on the surface of water that cannot harm things underwater
#define DMG_DIRECT								(1 << 28)
#define DMG_BUCKSHOT							(1 << 29)	// not quite a bullet. Little, rounder, different.
*/

stock bool:makedamage(attacker, target, damage, damagetype, Float:damageradius, Float:attackposition[3], String:weaponname[] = ""){

	new pointhurt = CreateEntityByName("point_hurt");
	
	if(pointhurt != -1){
	
		//목표가 있을 경우 목표 입력, 목표가 없을 경우 범위 공격을 하게된다
		if(target != -1){
			
			decl String:targetname[64];
			Format(targetname, 128, "%f%f", GetEngineTime(), GetRandomFloat());
			DispatchKeyValue(target,"TargetName", targetname);
			DispatchKeyValue(pointhurt,"DamageTarget", targetname);
			
		}
		
		//포인트허트 위치 지정
		DispatchKeyValueVector(pointhurt, "Origin", attackposition);
		
		//데미지 지정
		decl String:number[64];
		IntToString(damage, number, 64);
		DispatchKeyValue(pointhurt,"Damage", number);
		
		//데미지타입 지정
		IntToString(damagetype, number, 64);
		DispatchKeyValue(pointhurt,"DamageType", number);
		
		//데미지 범위 지정
		DispatchKeyValueFloat(pointhurt, "DamageRadius", damageradius);
		
		//웨폰네임 오버라이드
		if(!StrEqual(weaponname, "", false)){
			
			DispatchKeyValue(pointhurt,"classname", weaponname);
			
		}
		
		DispatchSpawn(pointhurt);
		
		AcceptEntityInput(pointhurt, "Hurt", attacker != -1 ? attacker : 0);
		
		AcceptEntityInput(pointhurt, "Kill");
		
		return true;
		
	}else{
		
		return false;
		
	}

}

stock bool:Callback_TraceFilter( iEntity, iContentsMask ) {
	if( IsValidEntity( iEntity ) && !IsValidEdict( iEntity ) )
		return true;
	new String:strClassname[32];
	GetEntityClassname( iEntity, strClassname, sizeof( strClassname ) );
	if( StrEqual( strClassname, "player", false ) )
		return false;
	return true;
}

stock PlayerEyeAngleFrontPosition(player, Float:vectorTargetPos[3], Float:vectorTargetPos2[3]) {
	new Float:vecTarget[3], Float:vecEyeAngles[3], Float:vecEyeOrigin[3], Float:vecMaxs[3], Float:vecRayHit[3], Float:vecBuffer[3];
	GetClientEyePosition(player, vecEyeOrigin );
	GetClientEyeAngles(player, vecEyeAngles );
	GetEntPropVector(player, Prop_Send, "m_vecMaxs", vecMaxs );
			
	vecEyeAngles[0] = 0.0;
	vecEyeAngles[2] = 0.0;
			
	new Handle:hRay = TR_TraceRayFilterEx( vecEyeOrigin, vecEyeAngles, MASK_PLAYERSOLID, RayType_Infinite, Callback_TraceFilter );
			
	TR_GetEndPosition( vecRayHit, hRay );
	CloseHandle( hRay );
			
	GetAngleVectors( vecEyeAngles, vecBuffer, NULL_VECTOR, NULL_VECTOR );
			
	new Float:flDistance = FloatAbs( GetVectorDistance( vecEyeOrigin, vecRayHit, false ) );
	if( flDistance > 80.0 )
		flDistance -= 80.0;
	else
		flDistance = 0.0;
	flDistance += vecMaxs[0] + 15.0;
			
	for( new i = 0; i < 3; i++ )
		vecTarget[i] = vecRayHit[i] + vecBuffer[i] * -flDistance;
		
	vecBuffer[0] = vecTarget[0];
	vecBuffer[1] = vecTarget[1];
	vecBuffer[2] = vecTarget[2] + vecMaxs[2];
	

	hRay = TR_TraceRayFilterEx( vecTarget, vecBuffer, MASK_PLAYERSOLID, RayType_EndPoint, Callback_TraceFilter );
	if( TR_DidHit( hRay ) )
	{
		TR_GetEndPosition( vecRayHit, hRay );
		CloseHandle( hRay );
				
		flDistance = FloatAbs( GetVectorDistance( vecTarget, vecRayHit, false ) );
		if( flDistance >= vecMaxs[2] )
			vecTarget[2] -= ( vecMaxs[2] + 5.0 );
		else if( 0.0 < flDistance < vecMaxs[2] )
			vecTarget[2] -= ( vecMaxs[2] - flDistance + 5.0 );
	}
	else
		CloseHandle( hRay );

		
	vectorTargetPos[0] = vecTarget[0];
	vectorTargetPos[1] = vecTarget[1];
	vectorTargetPos[2] = vecTarget[2];
	
	vectorTargetPos2[0] = vecEyeAngles[0];
	vectorTargetPos2[1] = vecEyeAngles[1];
	vectorTargetPos2[2] = vecEyeAngles[2];
}